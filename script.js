const data = [
  {
      date: '2023-05-15T00:00:00+05:00',
      accepted: 0,
      notaccepted: 0,
  },
  {
      date: '2023-05-15T01:00:00+05:00',
      accepted: 4,
      notaccepted: 0,
  },
  {
      date: '2023-05-15T02:00:00+05:00',
      accepted: 2,
      notaccepted: 0,
  },
  {
      date: '2023-05-15T03:00:00+05:00',
      accepted: 6,
      notaccepted: 0,
  },
  {
      date: '2023-05-15T04:00:00+05:00',
      accepted: 9,
      notaccepted: 0,
  },
  {
      date: '2023-05-15T05:00:00+05:00',
      accepted: 5,
      notaccepted: 0,
  },
  {
      date: '2023-05-15T06:00:00+05:00',
      accepted: 16,
      notaccepted: 0,
  },
  {
      date: '2023-05-15T07:00:00+05:00',
      accepted: 25,
      notaccepted: 0,
  },
  {
      date: '2023-05-15T08:00:00+05:00',
      accepted: 36,
      notaccepted: 4,
  },
  {
      date: '2023-05-15T09:00:00+05:00',
      accepted: 81,
      notaccepted: 3,
  },
  {
      date: '2023-05-15T10:00:00+05:00',
      accepted: 110,
      notaccepted: 15,
  },
  {
      date: '2023-05-15T11:00:00+05:00',
      accepted: 102,
      notaccepted: 11,
  },
  {
      date: '2023-05-15T12:00:00+05:00',
      accepted: 98,
      notaccepted: 8,
  },
  {
      date: '2023-05-15T13:00:00+05:00',
      accepted: 116,
      notaccepted: 3,
  },
  {
      date: '2023-05-15T14:00:00+05:00',
      accepted: 145,
      notaccepted: 21,
  },
  {
      date: '2023-05-15T15:00:00+05:00',
      accepted: 145,
      notaccepted: 12,
  },
  {
      date: '2023-05-15T16:00:00+05:00',
      accepted: 150,
      notaccepted: 32,
  },
  {
      date: '2023-05-15T17:00:00+05:00',
      accepted: 143,
      notaccepted: 15,
  },
  {
      date: '2023-05-15T18:00:00+05:00',
      accepted: 134,
      notaccepted: 14,
  },
  {
      date: '2023-05-15T19:00:00+05:00',
      accepted: 111,
      notaccepted: 9,
  },
  {
      date: '2023-05-15T20:00:00+05:00',
      accepted: 95,
      notaccepted: 4,
  },
  {
      date: '2023-05-15T21:00:00+05:00',
      accepted: 55,
      notaccepted: 0,
  },
  {
      date: '2023-05-15T22:00:00+05:00',
      accepted: 24,
      notaccepted: 0,
  },
  {
      date: '2023-05-15T23:00:00+05:00',
      accepted: 9,
      notaccepted: 0,
  },
    
];
const data1 = [
  {
      date: '2023-05-15T00:00:00+05:00',
      accepted: 0,
      notaccepted: 0,
  },
  {
      date: '2023-05-15T01:00:00+05:00',
      accepted: 40,
      notaccepted: 0,
  },
  {
      date: '2023-05-15T02:00:00+05:00',
      accepted: 20,
      notaccepted: 0,
  },
  {
      date: '2023-05-15T03:00:00+05:00',
      accepted: 60,
      notaccepted: 0,
  },
  {
      date: '2023-05-15T04:00:00+05:00',
      accepted: 950,
      notaccepted: 0,
  },
  {
      date: '2023-05-15T05:00:00+05:00',
      accepted: 50,
      notaccepted: 0,
  },
  {
      date: '2023-05-15T06:00:00+05:00',
      accepted: 160,
      notaccepted: 0,
  },
  {
      date: '2023-05-15T07:00:00+05:00',
      accepted: 250,
      notaccepted: 0,
  },
  {
      date: '2023-05-15T08:00:00+05:00',
      accepted: 360,
      notaccepted: 40,
  },
  {
      date: '2023-05-15T09:00:00+05:00',
      accepted: 810,
      notaccepted: 30,
  },
  {
      date: '2023-05-15T10:00:00+05:00',
      accepted: 1100,
      notaccepted: 150,
  },
  {
      date: '2023-05-15T11:00:00+05:00',
      accepted: 1020,
      notaccepted: 110,
  },
  {
      date: '2023-05-15T12:00:00+05:00',
      accepted: 980,
      notaccepted: 80,
  },
  {
      date: '2023-05-15T13:00:00+05:00',
      accepted: 1160,
      notaccepted: 30,
  },
  {
      date: '2023-05-15T14:00:00+05:00',
      accepted: 1450,
      notaccepted: 210,
  },
  {
      date: '2023-05-15T15:00:00+05:00',
      accepted: 1450,
      notaccepted: 120,
  },
  {
      date: '2023-05-15T16:00:00+05:00',
      accepted: 1500,
      notaccepted: 320,
  },
  {
      date: '2023-05-15T17:00:00+05:00',
      accepted: 1430,
      notaccepted: 150,
  },
  {
      date: '2023-05-15T18:00:00+05:00',
      accepted: 1340,
      notaccepted: 140,
  },
  {
      date: '2023-05-15T19:00:00+05:00',
      accepted: 1110,
      notaccepted: 90,
  },
  {
      date: '2023-05-15T20:00:00+05:00',
      accepted: 950,
      notaccepted: 40,
  },
  {
      date: '2023-05-15T21:00:00+05:00',
      accepted: 550,
      notaccepted: 0,
  },
  {
      date: '2023-05-15T22:00:00+05:00',
      accepted: 240,
      notaccepted: 0,
  },
  {
      date: '2023-05-15T23:00:00+05:00',
      accepted: 90,
      notaccepted: 0,
  },
    
];

class BaseChartElement {
  constructor(data, chartState) {
    this.root = d3.create('svg:g');
    this.chartState = chartState;
    this.data = data;
  }
  getNode() {
    return this.root.node();
  }
}
class LeftAxis extends BaseChartElement {
  constructor(data, chartState) {
    super(data, chartState);
    this.setScale();
    this.setStyles();
  }
  setScale() {
    const {yMax, tickDividedBy, sizes, yScale} = this.chartState;

    const arr = new Array(yMax / tickDividedBy + 1).fill(0).map((m, i) => i * tickDividedBy);
    this.root
      .style('transform', `translate(${sizes.width + sizes.left}px, ${sizes.top}px)`)
      .call(d3.axisLeft().scale(yScale).tickValues(arr).tickSize(sizes.width))
  }
  setStyles() {
    this.root.attr('class', 'left-axis');
  }
  redraw() {
    this.setScale();
  }
}
class BottomAxis extends BaseChartElement {
  constructor(data, chartState) {
    super(data, chartState);
    this.setScale();
    this.setStyles();
  }
  setScale() {
    const g = this.root;
    const {sizes, xScale, yScale} = this.chartState;
    g
      .style('transform', `translate(${sizes.left}px,${yScale(0) + sizes.top}px)`)
      .call(d3.axisBottom().scale(xScale).ticks(d3.utcHour.every(1), d3.utcFormat('%H:%M')))
    g.selectAll('.tick line')
      .attr('style', `transform: translateY(${-yScale(0)}px)`)
      .attr('stroke', '#E1E1E1')
      .attr('stroke-dasharray', '2,2')
      .attr('y2', yScale(0));
    g.select('.domain').remove();
  }
  setStyles() {
    const g = this.root;
    g
      .classed('bottom-axis', true)
      .selectAll('text')
      .attr('transform', 'translate(-14,10)rotate(-90)')
      .style('text-anchor', 'end')
  }
  redraw() {
    this.setScale();
  }
}
class DataPath extends BaseChartElement {
  constructor(data, chartState, dataLineField) {
    super(data, chartState);

    this.dataLineField = dataLineField;

    this.lineNode = this.root.append('path');
    this.areaNode = this.root.append('path');

    this.setStyles();
    this.setScale();
  }
  setScale() {
    const {sizes, xScale, yScale} = this.chartState;

    this.line = d3.line().curve(d3.curveBumpX).x((d) => xScale(new Date(d.date))).y(d => yScale(d[this.dataLineField]));
    this.area = d3.area().curve(d3.curveBumpX).x((d) => xScale(new Date(d.date))).y1(d => yScale(d[this.dataLineField]));
    this.area.y0(sizes.height);

    this.areaNode.attr('d', this.area(this.data));
    this.lineNode.datum(this.data).attr('d', this.line);
  }
  setStyles() {
    const dataLine = this.chartState.dataLines.find(d => d.field === this.dataLineField);
    const { defsNode } = this.chartState;
    const gradient = defsNode.append('linearGradient').attr('id', 'g-' + dataLine.field).attr('gradientTransform', 'rotate(90)');
    gradient.append('stop').attr('offset', '0%').attr('stop-color', dataLine.color).attr('stop-opacity', '0.15');
    gradient.append('stop').attr('offset', '100%').attr('stop-color', 'white').attr('stop-opacity', '0.15');

    this.areaNode.attr('fill', `url(#g-${dataLine.field})`);
    this.lineNode.attr('stroke', dataLine.color).attr('stroke-width', '2px').attr('fill', 'none');
  }
  redraw(data) {
    this.data = data;
    this.setScale();
  }
}
class DataLine {
    constructor(name, field, color) {
        this.name = name;
        this.field = field;
        this.color = color;
        this.textVar = null; // В этой переменной будет храниться ссылка на заголовок в тултипе
    }
}
const dataLines = [
    new DataLine('Входящие', 'accepted', '#397AF5'),
    new DataLine('Обработанные', 'notaccepted', '#00CC56'),
]

const [min,max] = d3.extent(data, d => new Date(d.date).getHours());
const delta = max - min;

class Tooltip extends BaseChartElement {
  constructor(data, chartState) {
    super(data, chartState);

    this.tooltipHeight = 52 + chartState.dataLines.length * 20 + chartState.dataLines.length * (4 - 1) + 16;
    this.createTooltip();
    this.initEvent();
  }
  createTooltip() {
    const yOffset = 14;
    const tooltipHeight = this.tooltipHeight;
    const tooltip = this.root.append('svg:g');

    const { dataLines } = this.chartState;
    
    tooltip
      .style('opacity', '0')
      .attr('pointer-events', 'none')
      .style('letter-spacing', '0.07px')
      .style('font-weight', '500')
      .style('font-size', '14px')
      .style('fill', '#fff');

    const wrapG = tooltip.append('svg:g');
    wrapG
      .attr('fill', '#454142')
      .attr('opacity', 0.92)
    wrapG
      .append('path')
      .attr('d', 'M9.46326 13.3346C10.2583 14.223 11.649 14.223 12.444 13.3346L21.3937 3.33372C22.5466 2.0454 21.6322 0 19.9033 0H2.00392C0.275054 0 -0.639356 2.0454 0.513553 3.33372L9.46326 13.3346Z')
      .attr('transform', `translate(${90},${ tooltipHeight - 3 })`) // 91 - половина ширины rect минус половина ширины ярлычка path
    wrapG
      .append('rect')
      .attr('rx', 6)
      .attr('x', 0)
      .attr('y', 0)
      .attr('width', 203)
      .attr('height', tooltipHeight)
        
    const tooltipTitle = tooltip.append('text')
    tooltipTitle
      .attr('x', 102)
      .attr('y', yOffset + 16)
      .style('text-anchor', 'middle')

    tooltip.append('rect')
      .attr('x', 16)
      .attr('y', 44)
      .attr('fill', 'rgba(255,255,255,0.3)')
      .attr('height', 1)
      .attr('width', 171)

    const circles = dataLines.map((d, idx) => {
      const circle = this.root.append('svg:circle')
      circle
        .style('display', 'none')
        .attr('r', 6)
        .attr('fill', d.color)
        .attr('stroke', '#fff')
        .attr('stroke-width', 2)

      const g1 = tooltip.append('svg:g');
      g1.attr('transform', `translate(16,${yOffset + 54 + 26 * idx})`)
      g1.append('text').text(d.name);
      d.textVar = g1.append('svg:text')
      d.textVar
        .style('text-anchor', 'end')
        .attr('x', 171);

      return circle;
    });

    this.tooltip = tooltip;
    this.tooltipTitle = tooltipTitle;
    this.circles = circles;
  }
  initEvent() {
    const tooltipOffset = {
      x: 101,
      y: this.tooltipHeight + 11 + 16 // родной размер, 11 высота ярлычка и 16 отступ для точки
    };
    const {yScale, xScale, sizes, dataWrapperNode, svgNode} = this.chartState;

    dataWrapperNode.on('mouseenter', m => {
      this.tooltip
        .transition()
        .duration(250)
        .style('opacity', 1)
      this.circles.forEach(c => {
        c.style('display', 'block');
      });
    });

    let lastSelectedData = null;
    dataWrapperNode.on('mousemove', m => {
      const [x, y] = d3.pointer(m);
      const i = Math.round(x / sizes.width * delta);
      const hoveredData = this.data[i];

      const xPos = xScale(new Date(hoveredData.date));

      const yPosList = dataLines.map(d => {
        return yScale(hoveredData[d.field]);
      });

      dataLines.forEach((d, idx) => {
        this.circles[idx]
          .attr('cx', xPos)
          .attr('cy', yPosList[idx])
      });

      this.tooltip.attr('transform', `translate(${xPos - tooltipOffset.x},${yPosList[0] - tooltipOffset.y})`)

      if(lastSelectedData && lastSelectedData.i !== i) {
          lastSelectedData.yTick.classed('selected', false)
          lastSelectedData = null
      }
      if(!lastSelectedData) {
          lastSelectedData = {
              yTick: svgNode.select(`.bottom-axis .tick:nth-child(${i + 1})`),
              i
          }
          lastSelectedData.yTick.classed('selected', true)
      }
      this.tooltipTitle.text(hoveredData.date.slice(11,16))
      dataLines.forEach(r => {
          r.textVar.selection().text(hoveredData[r.field])
      });
    });

    dataWrapperNode.on('mouseleave', () => {
      this.tooltip
          .transition()
          .duration(250)
          .style('opacity', '0')
      this.circles.forEach(c => {
        c.style('display', 'none');
      });
      if(lastSelectedData) {
          lastSelectedData.yTick.classed('selected', false)
          lastSelectedData = null;
      }
    });
  }
  redraw(data) {
    this.data = data;
  }
}
class Legend extends BaseChartElement {
  constructor(data, chartState) {
    super(data, chartState);
    this.root = d3.create('div'); // Legend является html элементом, а BaseChartElement создает svg элементы

    this.root.classed('c-chart-info', true);
    const legendGroup = this.root.append('div').classed('c-chart-info__wrap c-chart-info__wrap--small-size', true);
    const totalGroup = this.root.append('div').classed('c-chart-info__wrap c-chart-info__wrap--end-pos', true);

    this.totalElements = [];
    this.data = data;

    legendGroup.selectAll('div').data(chartState.dataLines).enter().insert((d) => this.createLegend(d));
    totalGroup.selectAll('div').data(chartState.dataLines).enter().insert((d) => {
      const { node, valueNode } = this.createTotal(d);
      this.totalElements.push({
        node: valueNode,
        field: d.field
      });
      return node;
    });
    
    this.root.style('padding-left', chartState.sizes.left + 'px').style('padding-right', chartState.sizes.right + 'px');
  }
  redraw(data) {
    this.data = data;
    this.totalElements.forEach(({node, field}) => {
      node.text(this.getMax(data, field));
    });
  }
  getMax(data, field) {
    return data.reduce((acc, curr) => {
      return acc + curr[field];
    }, 0);
  }
  createLegend(dataLine) {
    const legend = d3.create('div');
    legend.classed('c-legend', true);
    legend.append('div').classed('c-legend__color', true).style('background-color', dataLine.color);
    legend.append('p').classed('c-legend__name', true).text(dataLine.name);
    
    return legend.node();
  }
  createTotal(dataLine) {
    const data = this.data;

    const total = d3.create('div');
    total.classed('c-total', true);
    total.append('p').classed('c-total__name', true).text(dataLine.name);
    const max = this.getMax(data, dataLine.field);
    const valueNode = total.append('p');
    valueNode.classed('c-total__value', true).text(max);

    return {
      node: total.node(),
      valueNode
    }
  }
}

class ChartParamsGroup {
  sizes;
  yMax;
  tickDividedBy;
  dataLines;
  dataWrapperNode;
  svgNode;
  xScale;
  yScale;
}

class Chart {
  constructor(data, options = {}) {
    const chart = d3.select('#chart');
    const svg = chart.append('svg');

    // ChartState просто группирует необходимые для чартов данные, чтобы не раздувать интерфейсы функций и конструкторов
    const chartState = new ChartParamsGroup();
    this.chartState = chartState;

    const sizes = {
      top: 22,
      left: 86,
      right: 34,
      bottom: 94,
      width: 0,
      height: 389,
      totalWidth: chart.node().clientWidth,
      totalHeight: 0
    };
    sizes.width = sizes.totalWidth - sizes.left - sizes.right;
    sizes.totalHeight = sizes.height + sizes.top + sizes.bottom;
    chartState.sizes = sizes;

    svg.attr('width', sizes.totalWidth + 'px');
    svg.attr('height', sizes.totalHeight + 'px');

    this.data = data;
    this.calculateMax();

    const dataWrapper = d3.create('svg:g').style('transform', `translate(${ sizes.left }px,${ sizes.top }px)`);
    chartState.dataWrapperNode = dataWrapper;

    const yScale = d3.scaleLinear([0, chartState.yMax], [sizes.height,0]);
    const xScale = d3.scaleTime([new Date('2023-05-15T00:00:00+05:00'), new Date('2023-05-15T23:00:00+05:00')], [0, sizes.width]);

    chartState.dataLines = options.dataLines;
    chartState.xScale = xScale;
    chartState.yScale = yScale;
    chartState.svgNode = svg;
    
    const bottomAxis = new BottomAxis(data, chartState);
    const tooltip = new Tooltip(data, chartState);
    const legend = new Legend(data, chartState);
    const leftAxis = new LeftAxis(data, chartState);
    
    const defs = svg.append('defs');
    chartState.defsNode = defs;
    
    dataWrapper.append('rect').attr('width', sizes.width).attr('height',sizes.height).attr('fill','transparent');

    this.dataPaths = [];
    options.dataLines.forEach(d => {
      const p = new DataPath(data, chartState, d.field);
      this.dataPaths.push(p);
      this.appendSingle(dataWrapper, () => p.getNode());
    });
    
    this.appendSingle(chart, () => legend.getNode(), true);
    this.appendSingle(svg, () => leftAxis.getNode());
    this.appendSingle(svg, () => bottomAxis.getNode());
    this.appendSingle(svg, () => dataWrapper.node());
    this.appendSingle(dataWrapper, () => tooltip.getNode());

    this.legend = legend;
    this.leftAxis = leftAxis;
    this.bottomAxis = bottomAxis;
    this.tooltip = tooltip;
  }
  appendSingle(where, whatFn, prepend) {
    where.node()[prepend ? 'prepend' : 'append'](whatFn());
  }
  redraw(data) {
    this.data = data;
    this.calculateMax();

    this.chartState.yScale
      .domain([0, this.chartState.yMax])

    this.leftAxis.redraw(data);
    this.bottomAxis.redraw(data);
    this.legend.redraw(data);
    this.dataPaths.forEach(d => d.redraw(data));
    this.tooltip.redraw(data);
  }
  calculateMax() {
    let yMax = 0;
    let tickDividedBy = 0;
    
    this.data.forEach(d => {
      yMax = Math.max(yMax, ...dataLines.map(s => d[s.field]));
    });
    let multiplyBy = 50;
    if(yMax < 50) {
      multiplyBy = 10;
    }
    tickDividedBy = Math.ceil(yMax / 500) * multiplyBy;
    yMax = Math.ceil(Math.round(yMax + yMax * 0.1) / tickDividedBy) * tickDividedBy;

    this.chartState.tickDividedBy = tickDividedBy;
    this.chartState.yMax = yMax;
  }
}

const chart = new Chart(data1, {
  dataLines
});

setTimeout(() => {
  chart.redraw(data);
}, 1000);